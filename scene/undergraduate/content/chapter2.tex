\chapter{相关工作}

\section{预训练语言模型在场景生成系统中的应用机制}

预训练语言模型也就是 Pretrained Language Models（PLMs），它是基于大规模语料来学习语言分布规律的通用建模方法，其核心要点是通过自监督学习掌握词序列的统计规律，并且在这个基础上实现对下游任务的泛化能力，在生成结构化代码的任务当中，本系统采用 Sentence-T5-large 作为预训练语言模型，通过 Transformer 架构实现对自然语言场景描述的语义向量编码，并基于向量相似度检索最匹配的场景模板，为后续结构化代码生成提供基础语义输入。此过程涉及对语言结构、上下文关系以及目标语言语法规则的综合建模能力。

\subsection{基于 Sentence-T5 的语义编码机制在本系统中的应用}

本系统在自然语言生成智能驾驶场景的过程中，采用了 Sentence-T5-large 模型作为语义编码器，用于从自然语言输入中提取语义向量并进行高效检索。Sentence-T5 是一种在 Google T5（Text-to-Text Transfer Transformer）模型基础上微调而来的句子级别语义模型，具备对中文自然语言场景描述进行高质量语义建模的能力。

T5 模型本质上基于 Transformer 架构，其核心在于自注意力机制（Self-Attention），用于捕捉输入序列中任意两个位置之间的依赖关系。在编码过程中，输入的自然语言描述首先通过嵌入层（Embedding）转化为向量形式，随后在多个 Transformer 编码器层中进行上下文建模，在每一层中通过如下公式计算注意力权重：

\begin{equation}
	\text{Attention}(Q, K, V) = \text{softmax}\left( \frac{QK^\top}{\sqrt{d_k}} \right)V
\end{equation}

其中 $Q$、$K$、$V$ 分别代表查询（Query）、键（Key）和值（Value）矩阵，$d_k$ 是缩放因子。该机制能够有效建立输入序列中任意位置之间的关系，从而捕捉复杂语义、空间关系与事件逻辑等特征。

在本系统中，Sentence-T5-large 模型被用来将用户输入的中文自然语言场景描述编码成固定长度的语义向量，该向量随后与预构建的场景语料库中的向量进行余弦相似度计算，实现语义级别的检索匹配。匹配结果将作为模板驱动模块的输入，生成初步的场景结构，后续再经过结构生成模块构造出符合 Scenic 语法规范的完整脚本。通过这一流程，语言模型不仅完成了对自然语言的理解，还建立起了从自由描述到结构模板的桥接机制，是本系统中自然语言到场景构建链路中的关键组件。


\subsection{自然语言生成结构化代码的建模逻辑}

把自然语言变成结构化代码的这个过程，本质上是把输入的非形式化且语义丰富自然语言映射到有严格语法和执行逻辑的目标代码语言里，这个映射包含着三个核心理论组件：


	 （1）语义建模（Semantic Modeling）：语言模型要先理解自然语言背后的意图，也就是用户描述里蕴含的操作对象、属性约束、空间关系和时间先后等语义信息，这部分依靠语言模型对上下文的长距离建模能力以及对词汇的语义表示能力 。
	
	 （2）语法约束建模（Syntactic Constraint Modeling）：目标语言像Scenic这类有着明确的语法规则以及结构限制，语言模型在预训练过程里学习了多种语言模式，还能内隐地掌握特定语言的文法结构来生成合法的结构化代码。
	
	 （3）结构对齐与表示变换（Structure Alignment）：自然语言可以让人自由地进行表达，而结构化代码属于高度约束的形式语言。语言模型借助自回归生成的过程，把自然语言里的结构信息逐步转化成代码片段，达成从开放式表述到约束式语言的对齐映射。


需要注意的是语言模型并非通过硬编码规则做语义转换，而是凭借大规模预训练获得的统计语言知识，在解码阶段依靠概率最大化来实现语言到代码的结构生成，这种方法具备通用性强和适应性高的优势，适合用于多领域的自然语言编程任务。
另外在结构生成的过程当中，可以引入显式语义约束机制或者模板结构，像代码前缀提示这类，以此进一步提升生成代码的可控性与可解释性。
\section{自然语言到交通场景的语义建模}

把自然语言描述转变为可执行的交通仿真场景，关键之处在于对语义信息做结构化建模，交通场景一般有着复杂的空间布局、多主体互动且时序性强等特征，所以要从自然语言里精准提取出参与实体、行为属性、空间关系以及时间逻辑，并且构建能被场景引擎识别和执行的语义表示结构，本节围绕场景语义结构分析与关键元素抽取、时序关系与交通意图建模这两个方面展开论述。

\subsubsection{场景语义结构分析与关键元素抽取}

交通场景里的自然语言一般会包含多个核心组成部分，像交通参与者（例如车辆、行人、自行车等）、空间约束（比如道路类型、位置关系）、行为动作（像是“行驶”“等待”“穿越”）以及环境条件（例如天气、时间、信号灯状态），语义结构分析的目标是从原始语句当中建立出如下形式的结构化语义表示。

\begin{equation}
	\text{Scene} = \{ \text{Agents}, \text{Actions}, \text{Locations}, \text{Relations}, \text{Conditions} \}
\end{equation}

其中：Agents表示参与主体及其类型（如一辆蓝色轿车、自行车、行人等）；Actions表示行为描述，如“驶入交叉口”、“等待信号”、“加速通过”等；Locations表示空间位置或背景信息，如“在红绿灯前”、“十字路口中央”、“左侧车道”；Relations表示主体之间的空间和逻辑关系，如“位于...左侧”、“跟随...行驶”；Conditions表示上下文条件，如“在夜间”、“红灯状态”、“雨天”等。


抽取过程是依靠语言模型对上下文依存关系的建模能力来开展的，同时配合命名实体识别（NER）、依存句法分析（Dependency Parsing）等语言学工具，能够形成初步的语义结构，在本系统当中，语义结构会进一步映射为Scenic或Carla里支持的场景构造要素，以此实现语义向结构化语言的桥接。

\subsection{时序关系与交通意图建模}

交通场景可不只是静态配置这么简单，还涉及高度动态化的行为序列以及意图表达，自然语言里常常包含清晰或者隐含的时间逻辑，像“接着”“在……之后”“同时”这类信息，对于还原真实交通过程起着关键作用，时序关系建模的目标是把事件按照逻辑顺序组织成一个有向图或者序列，每个事件节点包含主体、动作以及发生时间，具体形式如下：
\begin{equation}
	\text{Timeline} = \left[ e_1 \rightarrow e_2 \rightarrow \cdots \rightarrow e_n \right], \quad e_i = (\text{Agent}, \text{Action}, \text{Time})
\end{equation}

借助语言模型对事件触发词以及像“当……时”“随后”这类连接词的建模能力，能够自动推理出事件之间的因果和先后关系并形成场景执行逻辑路径，另外交通意图建模所关注的是参与主体行为背后的目标导向性，比如“车辆试图避让行人”这种表述不仅描述了一个行为，还隐含着“行人优先”的交通规则与主车的决策意图，这类意图信息对于像 Carla 的行为树或触发机制这样的场景控制逻辑有着重要价值，可通过对谓词、助动词以及上下文环境进行深度理解来实现建模。


\section{Scenic语言的形式化语义与表达能力}

Scenic语言是专门面向智能驾驶场景的描述性语言，它主要目标是借助简洁且强大的语法结构，把复杂交通场景转化成可执行的仿真代码，为让语言具备高效表达能力和高度可扩展性，Scenic语言将形式化的语法设计和概率建模结合起来，通过对交通场景进行准确描述，能够生成包含多主体且行为多样化的复杂仿真环境，本节会从Scenic的语法设计与概率建模、Scenic在智能驾驶场景中的优势分析这两个方面展开详细讨论。

\subsection{Scenic的语法设计与概率建模}

Scenic语言语法设计是有效表达交通场景的基础，Scenic核心在于用简单面向对象描述方式，支持对交通参与者及空间位置等灵活建模，其语法结构支持层次化描述能精准构建场景元素，Scenic语法设计遵循以下几个基本原则：


面向对象建模：Scenic通过对“对象”进行定义，像车辆、行人这类，同时也对“对象属性”加以明确，比如位置、速度、尺寸这些，以此来构建一个高层次的交通场景。

行为定义：系统支持对交通参与者的动作（像“加速”“刹车”这类动作）以及事件（例如“碰撞”这样的事件）进行定义。

空间约束与条件：Scenic能够对空间约束进行定义，像“在道路上”这种，还能定义基于条件的约束，例如“当交通信号为红色时”。


Scenic的关键特性之一是支持概率建模，允许在场景生成时引入随机性和不确定性。通过概率分布的引入，Scenic能够模拟复杂的交通情境，生成多样化且高度不确定的场景。例如，车辆的初始位置、速度、甚至行为都可以通过概率分布进行建模，以更好地贴近真实世界中交通流的动态性。

\begin{equation}
	P(\text{Scene}) = \int_{\Omega} P(\text{Elements} | \text{Conditions}) d\Omega
\end{equation}

在此公式中，$P(\text{Scene})$ 表示生成场景的概率，$\text{Elements}$ 代表场景中各种元素（如车辆、行人等），而 $\Omega$ 表示所有可能的场景配置空间。通过这种概率建模，Scenic可以在多种不确定性下生成具有高度真实性和多样性的场景。


\section{智能驾驶仿真平台 CARLA 与本系统的集成机制}

本系统构建的智能驾驶场景生成平台基于 CARLA（Car Learning to Act）作为底层仿真执行环境。CARLA 是一款开源的高保真自动驾驶模拟器，具备复杂交通环境建模、传感器模拟、物理驱动与多主体交互等功能，广泛用于自动驾驶系统的测试验证。系统中生成的结构化场景代码（基于 Scenic 表达）需要与 CARLA 无缝集成，才能完成从自然语言描述到仿真结果输出的完整闭环。

本节将重点介绍本系统如何通过 API 调用、仿真调度和代码结构设计，将生成的场景脚本自动加载并执行于 CARLA 平台。

\subsection{本系统中的 CARLA 场景接入方式}

本系统通过 Python 脚本与 CARLA 的客户端接口交互，实现自动化场景加载与仿真调度。具体接入方式包括以下三个方面：


	（1）Scenic 脚本解析与实体注入：由自然语言生成的 Scenic 脚本将描述交通参与者的位置、动作与环境约束。本系统基于 Scenic 官方提供的解析器 ScenicSimulator，将其转化为 CARLA 所需的地图配置、初始状态及行为逻辑，并通过内部封装的 ScenicRunner 类完成实体创建与行为注入。
	
	（2）仿真控制与环境配置：系统调用 CARLA 的 Python API，在指定端口连接仿真服务器并设置同步模式、地图名称、天气参数、时间步长等基础环境，确保生成场景能够稳定加载和运行。仿真控制逻辑封装在 `ScenicRunnerDynamic.py` 模块中，支持多场景批量运行与日志记录。
	
	（3）数据采集与评估接口：CARLA 提供的传感器数据流（如 RGB 摄像头、激光雷达）被系统用于场景运行效果展示与性能评估。系统支持自动截图、轨迹输出和行为评分，为后续的性能对比与优化提供基础数据。

与通用 CARLA 使用方式不同，本系统实现了从自然语言到仿真执行的端到端流程，只需输入中文场景描述，即可自动完成 Scenic 脚本生成、CARLA 场景加载与仿真结果输出，极大简化了传统场景构建与接入的开发成本。


\subsection{Scenic 与 CARLA 的联合仿真执行流程}

本系统实现了 Scenic 与 CARLA 平台的高度集成，构建了一个完整的自然语言到仿真执行的自动化流程。用户首先通过图形化界面或命令行输入中文自然语言描述，例如“蓝色轿车在路口等待红灯”这样的交通场景需求。系统接收到输入后，会调用基于 Transformer 架构的 Sentence-T5 模型对输入语句进行语义向量编码，并在预构建的语料库中检索与其语义最接近的场景模板结构，从而快速确定候选场景结构与参与元素。

在语义匹配完成后，系统将基于匹配到的模板构造一份符合 Scenic 语法规范的场景脚本。该脚本会明确指定交通参与者的类型、数量、初始位置、行为动作及其时序逻辑，形成完整的结构化场景表达。随后，生成的 Scenic 脚本被传入 Scenic 官方提供的 ScenicSimulator，并在本系统封装的 ScenicRunnerDynamic 模块中完成解析与实体化处理，从而将静态的场景脚本转化为 CARLA 中可执行的仿真场景实例。

完成脚本加载后，系统会通过 CARLA 提供的 Python API 启动仿真环境，加载地图、设置天气、创建交通主体，并执行场景中定义的行为。整个仿真过程将按照同步控制模式运行，并自动保存仿真运行过程中的截图或视频帧，同时采集轨迹、传感器数据等信息以用于后续评估。通过上述模块化的处理流程，本系统实现了自然语言→语义编码→结构生成→仿真执行的端到端闭环集成，有效提升了智能驾驶场景生成的效率、语义一致性与自动化水平。



